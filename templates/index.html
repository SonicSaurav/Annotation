<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conversation Data Annotation Tool</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
        }
        .container-fluid {
            padding: 20px;
        }
        .card {
            margin-bottom: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .card-header {
            background-color: #f1f3f5;
            font-weight: bold;
            border-radius: 10px 10px 0 0 !important;
        }
        .conversation-box {
            height: 400px;
            overflow-y: auto;
            padding: 15px;
            background-color: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }
        .user-message {
            background-color: #e9ecef;
            padding: 10px 15px;
            border-radius: 15px;
            margin-bottom: 10px;
            max-width: 80%;
            align-self: flex-start;
        }
        .assistant-message {
            background-color: #d0e8ff;
            padding: 10px 15px;
            border-radius: 15px;
            margin-bottom: 10px;
            max-width: 80%;
            align-self: flex-end;
            margin-left: auto;
        }
        .message-container {
            display: flex;
            flex-direction: column;
        }
        .code-block {
            font-family: monospace;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-radius: 50%;
            border-top: 5px solid #3498db;
            width: 30px;
            height: 30px;
            animation: spin 2s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .workflow-steps {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .workflow-step {
            flex: 1;
            text-align: center;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            position: relative;
        }
        .workflow-step.active {
            background-color: #cfe2ff;
            font-weight: bold;
        }
        .workflow-step.completed {
            background-color: #d1e7dd;
        }
        .workflow-step:not(:last-child)::after {
            content: "â†’";
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
        }
        .log-message {
            font-family: monospace;
            padding: 5px;
            margin: 2px 0;
            border-radius: 3px;
        }
        .log-message.debug {
            color: #0d6efd;
            background-color: #e6f2ff;
        }
        .log-message.error {
            color: #dc3545;
            background-color: #f8d7da;
        }
        .log-message.warning {
            color: #ffc107;
            background-color: #fff3cd;
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid #dee2e6;
            margin-bottom: 15px;
        }
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }
        .tab.active {
            background-color: #ffffff;
            border-bottom: 1px solid #ffffff;
            margin-bottom: -1px;
            font-weight: bold;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Conversation Data Annotation Tool</a>
            <div class="d-flex">
                <button id="saveConversationBtn" class="btn btn-success me-2" disabled>
                    <i class="bi bi-save"></i> Save Conversation
                </button>
                <button id="resetBtn" class="btn btn-danger">
                    <i class="bi bi-arrow-counterclockwise"></i> Reset
                </button>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- Left Column: Workflow Steps & Conversation Display -->
            <div class="col-lg-6">
                <!-- Workflow Steps -->
                <div class="card">
                    <div class="card-header">Workflow Steps</div>
                    <div class="card-body">
                        <div class="workflow-steps">
                            <div id="step1" class="workflow-step active">
                                1. Generate Persona
                            </div>
                            <div id="step2" class="workflow-step">
                                2. Generate Requirements
                            </div>
                            <div id="step3" class="workflow-step">
                                3. Initial User Message
                            </div>
                            <div id="step4" class="workflow-step">
                                4. Process Response
                            </div>
                            <div id="step5" class="workflow-step">
                                5. Next User Message
                            </div>
                        </div>
                        <div class="d-flex justify-content-between">
                            <button id="startBtn" class="btn btn-primary">
                                <i class="bi bi-play-fill"></i> Start Workflow
                            </button>
                            <div>
                                <button id="clearBtn" class="btn btn-warning me-2" disabled>
                                    <i class="bi bi-trash"></i> Clear
                                </button>
                                <button id="nextBtn" class="btn btn-success" disabled>
                                    <i class="bi bi-arrow-right"></i> Next
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Conversation Display -->
                <div class="card">
                    <div class="card-header">Conversation</div>
                    <div class="card-body">
                        <div id="conversationBox" class="conversation-box">
                            <div class="message-container">
                                <!-- Messages will be appended here -->
                            </div>
                        </div>
                        <div class="mt-3">
                            <button id="regenerateBtn" class="btn btn-warning" disabled>
                                <i class="bi bi-arrow-repeat"></i> Regenerate Assistant Response
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Saved Conversations -->
                <div class="card">
                    <div class="card-header">Saved Conversations</div>
                    <div class="card-body">
                        <div id="savedConversationsList">
                            <!-- Saved conversations will be listed here -->
                            <p class="text-muted">No conversations saved yet.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Data Displays -->
            <div class="col-lg-6">
                <!-- Tabs for Data Display -->
                <div class="card">
                    <div class="card-header">Data Analysis</div>
                    <div class="card-body">
                        <div class="tabs">
                            <div class="tab active" data-tab="ner">NER Results</div>
                            <div class="tab" data-tab="searchCall">Search Call</div>
                            <div class="tab" data-tab="searchResults">Search Results</div>
                            <div class="tab" data-tab="critique">Critique</div>
                            <div class="tab" data-tab="logs">Logs</div>
                        </div>

                        <!-- NER Results Tab -->
                        <div id="nerTab" class="tab-content active">
                            <h5>Named Entity Recognition Results</h5>
                            <div id="nerResults" class="code-block">
                                <span class="text-muted">No NER results available yet.</span>
                            </div>
                        </div>

                        <!-- Search Call Tab -->
                        <div id="searchCallTab" class="tab-content">
                            <h5>Search Call</h5>
                            <div id="searchCall" class="code-block">
                                <span class="text-muted">No search call available yet.</span>
                            </div>
                        </div>

                        <!-- Search Results Tab -->
                        <div id="searchResultsTab" class="tab-content">
                            <h5>Search Results</h5>
                            <div id="searchResults" class="code-block">
                                <span class="text-muted">No search results available yet.</span>
                            </div>
                        </div>

                        <!-- Critique Tab -->
                        <div id="critiqueTab" class="tab-content">
                            <h5>Response Critique</h5>
                            <div id="critique" class="code-block">
                                <span class="text-muted">No critique available yet.</span>
                            </div>
                        </div>

                        <!-- Logs Tab -->
                        <div id="logsTab" class="tab-content">
                            <h5>Real-time Logs</h5>
                            <div id="logs" class="code-block" style="height: 300px; overflow-y: auto;">
                                <div class="log-message debug">System initialized. Waiting for actions...</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Contextual Information -->
                <div class="card">
                    <div class="card-header">Contextual Information</div>
                    <div class="card-body">
                        <div class="mb-3">
                            <h5>Persona</h5>
                            <div id="personaDisplay" class="code-block">
                                <span class="text-muted">No persona generated yet.</span>
                            </div>
                        </div>
                        <div>
                            <h5>Requirements</h5>
                            <div id="requirementsDisplay" class="code-block">
                                <span class="text-muted">No requirements generated yet.</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for saving conversation -->
    <div class="modal fade" id="saveConversationModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Save Conversation</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="conversationName" class="form-label">Conversation Name</label>
                        <input type="text" class="form-control" id="conversationName" placeholder="Enter a name for this conversation">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveConversationModalBtn">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Modal -->
    <div class="modal fade" id="loadingModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-body text-center p-4">
                    <div class="loader mx-auto mb-3"></div>
                    <h5 id="loadingMessage">Processing...</h5>
                    <p class="text-muted" id="loadingSubMessage">This may take a few moments</p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/socket.io/client-dist/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        const USE_DIRECT_FETCH = true;
        document.addEventListener('DOMContentLoaded', function() {
    // DOM Element References
    const startBtn = document.getElementById('startBtn');
    const nextBtn = document.getElementById('nextBtn');
    const clearBtn = document.getElementById('clearBtn');
    const resetBtn = document.getElementById('resetBtn');
    const regenerateBtn = document.getElementById('regenerateBtn');
    const saveConversationBtn = document.getElementById('saveConversationBtn');
    const saveConversationModalBtn = document.getElementById('saveConversationModalBtn');
    
    const conversationBox = document.getElementById('conversationBox');
    const nerResults = document.getElementById('nerResults');
    const searchCall = document.getElementById('searchCall');
    const searchResults = document.getElementById('searchResults');
    const critique = document.getElementById('critique');
    const logs = document.getElementById('logs');
    const personaDisplay = document.getElementById('personaDisplay');
    const requirementsDisplay = document.getElementById('requirementsDisplay');
    const savedConversationsList = document.getElementById('savedConversationsList');
    
    const steps = {
        step1: document.getElementById('step1'),
        step2: document.getElementById('step2'),
        step3: document.getElementById('step3'),
        step4: document.getElementById('step4'),
        step5: document.getElementById('step5')
    };
    
    // State variables
    let currentStep = 1;
    let conversationId = null;
    let currentTaskId = null;
    
    // Modals
    const loadingModal = new bootstrap.Modal(document.getElementById('loadingModal'));
    const saveConversationModal = new bootstrap.Modal(document.getElementById('saveConversationModal'));
    
    // Tab functionality
    const tabs = document.querySelectorAll('.tab');
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            // Remove active class from all tabs
            tabs.forEach(t => t.classList.remove('active'));
            // Add active class to clicked tab
            tab.classList.add('active');
            
            // Hide all tab content
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            // Show corresponding tab content
            const tabContentId = tab.getAttribute('data-tab') + 'Tab';
            document.getElementById(tabContentId).classList.add('active');
        });
    });

    // Add debug button to UI
    const debugBtn = document.createElement('button');
    debugBtn.id = 'debugBtn';
    debugBtn.className = 'btn btn-info ms-2';
    debugBtn.innerHTML = '<i class="bi bi-bug"></i> Debug';
    debugBtn.addEventListener('click', debugConversation);
    resetBtn.parentNode.appendChild(debugBtn);
    
    // Event Listeners
    startBtn.addEventListener('click', () => {
        initConversation();
    });
    
    nextBtn.addEventListener('click', () => {
        if (currentStep === 5) {
            generateNextUserMessage();
        }
    });
    
    clearBtn.addEventListener('click', () => {
        clearConversation();
    });
    
    resetBtn.addEventListener('click', () => {
        resetEverything();
    });
    
    regenerateBtn.addEventListener('click', () => {
        regenerateAssistantResponse();
    });
    
    saveConversationBtn.addEventListener('click', () => {
        saveConversationModal.show();
    });
    
    saveConversationModalBtn.addEventListener('click', () => {
        const name = document.getElementById('conversationName').value || `Conversation-${new Date().toISOString().slice(0, 19).replace('T', '-').replace(/:/g, '')}`;
        saveConversation(name);
        saveConversationModal.hide();
    });
    
    // Initialize all the enhancements
    setupSocketHandlers();
    setupPeriodicDataChecks();
    addTroubleshootButton();
    enhanceSocketConnection();
    restoreBackups();
    
    // Update next button to use the new handler
    nextBtn.removeEventListener('click', null);
    nextBtn.addEventListener('click', handleNextButtonClick);
    
    // Set up session status checking
    setInterval(checkSessionStatus, 60000);
    
    // Load initial data
    getSavedConversations();
    
    console.log('Enhanced UI initialized');
    addLogMessage('Enhanced UI initialized', 'debug');
});
            
            function showLoading(message, subMessage = 'This may take a few moments') {
                document.getElementById('loadingMessage').textContent = message;
                document.getElementById('loadingSubMessage').textContent = subMessage;
                loadingModal.show();
            }
            
            function hideLoading() {
                loadingModal.hide();
            }
            
            function setActiveStep(step) {
                currentStep = step;
                Object.values(steps).forEach((stepEl, index) => {
                    stepEl.classList.remove('active', 'completed');
                    if (index + 1 < step) {
                        stepEl.classList.add('completed');
                    } else if (index + 1 === step) {
                        stepEl.classList.add('active');
                    }
                });
                
                if (step > 1) {
                    nextBtn.disabled = false;
                    clearBtn.disabled = false;
                    saveConversationBtn.disabled = false;
                    
                    const conversation = getConversationFromUI();
                    if (conversation.length > 0 && conversation[conversation.length - 1].role === 'assistant') {
                        regenerateBtn.disabled = false;
                    } else {
                        regenerateBtn.disabled = true;
                    }
                }
            }
            
            function addMessageToUI(role, content) {
                const messageDiv = document.createElement('div');
                messageDiv.className = role === 'user' ? 'user-message' : 'assistant-message';
                messageDiv.textContent = content;
                conversationBox.querySelector('.message-container').appendChild(messageDiv);
                conversationBox.scrollTop = conversationBox.scrollHeight;
            }
            
            function getConversationFromUI() {
                const messages = conversationBox.querySelectorAll('.message-container > div');
                const conversation = [];
                
                messages.forEach(message => {
                    const role = message.classList.contains('user-message') ? 'user' : 'assistant';
                    conversation.push({
                        role: role,
                        content: message.textContent
                    });
                });
                
                return conversation;
            }

            function checkWebSocketConnection() {
    console.log('Checking WebSocket connection...');
    addLogMessage('Checking WebSocket connection...', 'debug');
    
    // Check if socket is connected
    if (socket.connected) {
        console.log('Socket is connected!');
        addLogMessage('Socket is connected! ðŸŸ¢', 'debug');
        
        // Test sending an event
        sendFeedback('WebSocket connection test', 'debug');
        
        // Call the check_webhook endpoint to test server-to-client communication
        axios.get(`/check_webhook?conversation_id=${conversationId}&message=UI-initiated test`)
            .then(response => {
                console.log('Check webhook response:', response.data);
                addLogMessage('Sent webhook test request', 'debug');
            })
            .catch(error => {
                console.error('Error checking webhook:', error);
                addLogMessage(`Error checking webhook: ${error.message}`, 'error');
            });
    } else {
        console.log('Socket is disconnected!');
        addLogMessage('Socket is disconnected! ðŸ”´', 'error');
        
        // Try to reconnect
        socket.connect();
        addLogMessage('Attempting to reconnect...', 'debug');
    }
}

function setupSocketHandlers() {
    // Remove any existing handlers to prevent duplicates
    socket.off('ner_extracted');
    socket.off('search_call_processed');
    socket.off('search_results');
    socket.off('critic_evaluation');
    socket.off('combined_critique');
    socket.off('model_response');
    socket.off('model_response_processed');
    socket.off('test_event');
}

// Fix 2: Add a function to send feedback to the server
function sendFeedback(message, type = 'debug') {
    axios.post('/feedback', {
        message: message,
        type: type,
        conversation_id: conversationId
    })
        .then(response => {
            console.log('Feedback sent:', response.data);
        })
        .catch(error => {
            console.error('Error sending feedback:', error);
        });
}

// Fix 3: Add direct API fetch methods for when WebSockets fail
function fetchNERResultsDirectly() {
    if (!conversationId) {
        console.error('No conversation ID available');
        addLogMessage('Cannot fetch NER results: No conversation ID', 'error');
        return;
    }
    
    axios.get(`/get_ner_results?conversation_id=${conversationId}`)
        .then(response => {
            if (response.data.status === 'success' && response.data.results) {
                nerResults.innerHTML = `<pre>${JSON.stringify(response.data.results, null, 2)}</pre>`;
                addLogMessage(`Successfully fetched NER results (source: ${response.data.source || 'API'})`, 'debug');
            } else {
                addLogMessage(`No NER results available: ${response.data.message}`, 'warning');
            }
        })
        .catch(error => {
            console.error('Error fetching NER results:', error);
            addLogMessage(`Error fetching NER results: ${error.message}`, 'error');
        });
}

function fetchSearchResultsDirectly() {
    if (!conversationId) {
        console.error('No conversation ID available');
        addLogMessage('Cannot fetch search results: No conversation ID', 'error');
        return;
    }
    
    axios.get(`/get_search_results?conversation_id=${conversationId}`)
        .then(response => {
            if (response.data.status === 'success' && response.data.results) {
                searchResults.innerHTML = `<pre>${JSON.stringify(response.data.results, null, 2)}</pre>`;
                addLogMessage(`Successfully fetched search results (source: ${response.data.source || 'API'})`, 'debug');
            } else {
                addLogMessage(`No search results available: ${response.data.message}`, 'warning');
            }
        })
        .catch(error => {
            console.error('Error fetching search results:', error);
            addLogMessage(`Error fetching search results: ${error.message}`, 'error');
        });
}

            
            function addLogMessage(message, type) {
                const logMessage = document.createElement('div');
                logMessage.className = `log-message ${type}`;
                logMessage.textContent = message;
                logs.appendChild(logMessage);
                logs.scrollTop = logs.scrollHeight;
            }
            
            const socket = io({
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000
            });
            
            socket.on('connect', () => {
                console.log('WebSocket connected!');
                addLogMessage('WebSocket connected', 'debug');
            });
            
            socket.on('connect_error', (error) => {
                console.error('WebSocket connection error:', error);
                addLogMessage(`WebSocket connection error: ${error.message}`, 'error');
            });
            
            socket.on('disconnect', () => {
                console.log('WebSocket disconnected');
                addLogMessage('WebSocket disconnected', 'debug');
            });
            
            socket.on('log_message', (data) => {
                addLogMessage(data.message, data.type);
            });
            
            socket.on('ner_extracted', (data) => {
                if (data.conversation_id === conversationId) {
                    nerResults.innerHTML = `<pre>${JSON.stringify(data.preferences, null, 2)}</pre>`;
                    addLogMessage('NER extraction completed', 'debug');
                }
            });
            
            socket.on('search_call_processed', (data) => {
                if (data.conversation_id === conversationId) {
                    searchCall.innerHTML = `<pre>${data.search_call}</pre>`;
                    addLogMessage('Search call processed', 'debug');
                }
            });
            
            socket.on('search_results', (data) => {
                if (data.conversation_id === conversationId) {
                    searchResults.innerHTML = `<pre>${JSON.stringify(data.record, null, 2)}</pre>`;
                    addLogMessage('Search results received', 'debug');
                }
            });
            
            socket.on('critic_evaluation', (data) => {
                if (data.conversation_id === conversationId) {
                    critique.innerHTML = `<pre>${JSON.stringify(data.critique, null, 2)}</pre>`;
                    addLogMessage('Critique evaluation completed', 'debug');
                }
            });
            
            socket.on('combined_critique', (data) => {
                if (data.conversation_id === conversationId) {
                    critique.innerHTML = `<pre>${JSON.stringify(data.critique, null, 2)}</pre>`;
                    addLogMessage('Combined critique completed', 'debug');
                }
            });
            
            socket.on('model_response', (data) => {
                console.log('Received model_response event:', data);
                
                if (data.conversation_id === conversationId) {
                    addLogMessage(`Received ${data.model} response`, 'debug');
                    
                    if (data.model === 'openai_o3-mini') {
                        if (currentStep === 1) {
                            personaDisplay.innerHTML = `<pre>${data.response}</pre>`;
                            addLogMessage('Updated persona display', 'debug');
                            generateRequirements(data.response);
                        } else if (currentStep === 2) {
                            requirementsDisplay.innerHTML = `<pre>${data.response}</pre>`;
                            addLogMessage('Updated requirements display', 'debug');
                            generateInitialUserMessage(data.response);
                        } else if (currentStep === 3 || currentStep === 5) {
                            addMessageToUI('user', data.response);
                            addLogMessage('Added user message to UI', 'debug');
                            addUserMessageToBackend(data.response);
                        }
                    }
                } else {
                    console.warn('Received model_response for different conversation_id', data.conversation_id);
                }
            });
            
            socket.on('model_response_processed', (data) => {
                if (data.conversation_id === conversationId) {
                    if (data.result && data.result.message) {
                        addMessageToUI('assistant', data.result.message.content);
                        updateConversationInBackend(data.result);
                        regenerateBtn.disabled = false;
                    }
                    
                    hideLoading();
                    
                    if (currentStep === 4) {
                        setActiveStep(5);
                    }
                }
            });
            
            function checkTaskStatus(taskId) {
                return axios.get(`/task_status/${taskId}`)
                    .then(response => {
                        console.log(`Task ${taskId} status:`, response.data);
                        return response.data;
                    })
                    .catch(error => {
                        console.error(`Error checking task status for ${taskId}:`, error);
                        return { state: 'ERROR', status: 'Error checking task status' };
                    });
            }
            
            function pollTaskCompletion(taskId, loadingMessage, subMessage = 'This may take a few moments') {
                document.getElementById('loadingMessage').textContent = loadingMessage;
                document.getElementById('loadingSubMessage').textContent = subMessage;
                
                console.log(`Polling task ${taskId} with message: ${loadingMessage}`);
                addLogMessage(`Polling task ${taskId}`, 'debug');
                
                currentTaskId = taskId;
                
                const interval = setInterval(() => {
                    checkTaskStatus(taskId).then(taskData => {
                        if (taskData.state === 'SUCCESS') {
                            clearInterval(interval);
                            addLogMessage(`Task ${taskId} completed successfully`, 'debug');
                            
                            setTimeout(() => {
                                if (loadingModal._element.classList.contains('show') && 
                                    document.getElementById('loadingMessage').textContent === loadingMessage) {
                                    
                                    console.warn('Task completed but UI not updated. Using direct result fetch.');
                                    addLogMessage('Task completed but UI not updated. Using direct result fetch.', 'warning');
                                    fetchDirectTaskResult(taskId);
                                }
                            }, 2000);
                        }
                        else if (taskData.state === 'FAILURE') {
                            clearInterval(interval);
                            hideLoading();
                            addLogMessage(`Task ${taskId} failed: ${taskData.error || 'Unknown error'}`, 'error');
                            alert(`Task failed: ${taskData.error || 'Unknown error'}`);
                        }
                    });
                }, 2000);
                
                setTimeout(() => {
                    clearInterval(interval);
                    
                    if (loadingModal._element.classList.contains('show') && 
                        document.getElementById('loadingMessage').textContent === loadingMessage) {
                        
                        console.warn(`Timeout reached for task ${taskId}. Using direct result fetch.`);
                        addLogMessage(`Timeout reached for task ${taskId}. Using direct result fetch.`, 'warning');
                        fetchDirectTaskResult(taskId);
                    }
                }, 60000);
            }
            function debugConversation() {
    axios.get(`/debug_conversation?conversation_id=${conversationId}`)
        .then(response => {
            console.log('Debug conversation data:', response.data);
            addLogMessage('Conversation debug data received - check console', 'debug');
            
            // Add to logs for easier viewing
            const logData = JSON.stringify(response.data, null, 2);
            addLogMessage(`Conversation data sources:\n${logData}`, 'debug');
        })
        .catch(error => {
            console.error('Error debugging conversation:', error);
            addLogMessage(`Error debugging conversation: ${error.message}`, 'error');
        });
}

// Add a debug button in the UI right after the resetBtn definition
const debugBtn = document.createElement('button');
debugBtn.id = 'debugBtn';
debugBtn.className = 'btn btn-info ms-2';
debugBtn.innerHTML = '<i class="bi bi-bug"></i> Debug';
debugBtn.addEventListener('click', debugConversation);
resetBtn.parentNode.appendChild(debugBtn);
            function handleTaskCompletionFallback(taskId, taskData) {
                console.log('Handling task completion fallback', taskId, taskData);
                
                setTimeout(() => {
                    if (currentStep === 1) {
                        fetchPersonaData();
                    }
                    else if (currentStep === 2 && personaDisplay.textContent.trim() !== 'No persona generated yet.') {
                        axios.get(`/get_requirements?conversation_id=${conversationId}`)
                            .then(response => {
                                if (response.data.status === 'success' && response.data.requirements) {
                                    requirementsDisplay.innerHTML = `<pre>${response.data.requirements}</pre>`;
                                    addLogMessage('Successfully fetched requirements data via API', 'debug');
                                    generateInitialUserMessage(response.data.requirements);
                                } else {
                                    const persona = personaDisplay.querySelector('pre').textContent;
                                    generateRequirements(persona);
                                }
                            })
                            .catch(error => {
                                console.error('Error fetching requirements:', error);
                                const persona = personaDisplay.querySelector('pre').textContent;
                                generateRequirements(persona);
                            });
                    }
                    else if (currentStep === 3 && requirementsDisplay.textContent.trim() !== 'No requirements generated yet.') {
                        axios.get(`/get_last_message?conversation_id=${conversationId}&type=user`)
                            .then(response => {
                                if (response.data.status === 'success' && response.data.message) {
                                    addMessageToUI('user', response.data.message);
                                    addLogMessage('Successfully fetched user message via API', 'debug');
                                    processModelResponse();
                                } else {
                                    const requirements = requirementsDisplay.querySelector('pre').textContent;
                                    generateInitialUserMessage(requirements);
                                }
                            })
                            .catch(error => {
                                console.error('Error fetching user message:', error);
                                const requirements = requirementsDisplay.querySelector('pre').textContent;
                                generateInitialUserMessage(requirements);
                            });
                    }
                    else if (currentStep === 4) {
                        axios.get(`/get_last_message?conversation_id=${conversationId}&type=assistant`)
                            .then(response => {
                                if (response.data.status === 'success' && response.data.message) {
                                    addMessageToUI('assistant', response.data.message);
                                    addLogMessage('Successfully fetched assistant message via API', 'debug');
                                    setActiveStep(5);
                                    hideLoading();
                                } else {
                                    processModelResponse();
                                }
                            })
                            .catch(error => {
                                console.error('Error fetching assistant message:', error);
                                hideLoading();
                            });
                    }
                    else if (currentStep === 5) {
                        generateNextUserMessage();
                    }
                    else {
                        hideLoading();
                    }
                }, 1000);
            }
            
            function storeModelResponse(model, response, step) {
                console.log(`Storing ${model} response for step ${step}`);
                
                axios.post('/store_model_response', {
                    conversation_id: conversationId,
                    model: model,
                    response: response,
                    step: step
                })
                    .then(response => {
                        console.log('Store model response result:', response.data);
                        addLogMessage(`Stored model response for step ${step}`, 'debug');
                    })
                    .catch(error => {
                        console.error('Error storing model response:', error);
                        addLogMessage(`Error storing model response: ${error.message}`, 'error');
                    });
            }

            function fetchDirectTaskResult(taskId) {
                console.log(`Fetching direct result for task ${taskId}`);
                addLogMessage(`Fetching direct result for task ${taskId}`, 'debug');
                
                axios.get(`/get_task_result/${taskId}`)
                    .then(response => {
                        console.log('Task result response:', response.data);
                        
                        if (response.data.status === 'success' && response.data.result) {
                            const result = response.data.result;
                            
                            if (currentStep === 1) {
                                personaDisplay.innerHTML = `<pre>${result}</pre>`;
                                addLogMessage('Retrieved persona directly from task result', 'debug');
                                generateRequirements(result);
                            }
                            else if (currentStep === 2) {
                                requirementsDisplay.innerHTML = `<pre>${result}</pre>`;
                                addLogMessage('Retrieved requirements directly from task result', 'debug');
                                generateInitialUserMessage(result);
                            }
                            else if (currentStep === 3 || currentStep === 5) {
                                addMessageToUI('user', result);
                                addLogMessage('Retrieved user message directly from task result', 'debug');
                                processModelResponse();
                            }
                            else if (currentStep === 4) {
                                console.log('Processing model response result:', result);
                                
                                if (typeof result === 'object' && result.message && result.message.content) {
                                    addMessageToUI('assistant', result.message.content);
                                    addLogMessage('Retrieved and displayed assistant message from task result', 'debug');
                                    updateConversationInBackend(result);
                                    regenerateBtn.disabled = false;
                                    setActiveStep(5);
                                    hideLoading();
                                } else {
                                    console.error('Model response result has unexpected format:', result);
                                    addLogMessage('Model response result has unexpected format', 'error');
                                    hideLoading();
                                }
                            }
                            else {
                                console.log('Unknown step for direct task result:', currentStep);
                                addLogMessage(`Unknown step ${currentStep} for direct task result`, 'warning');
                                hideLoading();
                            }
                        } else {
                            console.error('Failed to get task result or result is empty');
                            addLogMessage('Failed to get task result or result is empty', 'error');
                            hideLoading();
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching direct task result:', error);
                        addLogMessage(`Error fetching direct task result: ${error.message}`, 'error');
                        hideLoading();
                    });
            }
            
            function fetchPersonaData() {
                console.log('Fetching persona data via API');
                
                axios.get(`/get_persona?conversation_id=${conversationId}`)
                    .then(response => {
                        console.log('Persona API response:', response.data);
                        
                        if (response.data.status === 'success' && response.data.persona) {
                            personaDisplay.innerHTML = `<pre>${response.data.persona}</pre>`;
                            addLogMessage(`Successfully fetched persona data via API (source: ${response.data.source})`, 'debug');
                            generateRequirements(response.data.persona);
                        } else {
                            console.log('Persona not found in session or file, trying direct task result');
                            
                            if (currentTaskId) {
                                fetchDirectTaskResult(currentTaskId);
                            } else {
                                console.error('No task ID available');
                                addLogMessage('No task ID available for direct result fetch', 'error');
                                hideLoading();
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching persona:', error);
                        addLogMessage(`Error fetching persona: ${error.message}`, 'error');
                        
                        if (currentTaskId) {
                            fetchDirectTaskResult(currentTaskId);
                        } else {
                            hideLoading();
                        }
                    });
            }
            
            function initConversation() {
                showLoading('Initializing conversation...', 'Setting up workflow');
                
                axios.post('/init')
                    .then(response => {
                        conversationId = response.data.conversation_id;
                        currentTaskId = response.data.task_id;
                        
                        addLogMessage(`Conversation initialized with ID: ${conversationId}`, 'debug');
                        pollTaskCompletion(currentTaskId, 'Generating persona...');
                    })
                    .catch(error => {
                        console.error('Error initializing conversation:', error);
                        addLogMessage(`Error initializing conversation: ${error.message}`, 'error');
                        hideLoading();
                    });
            }
            
            function generateRequirements(persona) {
                showLoading('Generating requirements...', 'Based on persona');
                
                axios.post('/generate_requirements', {
                    persona: persona,
                    conversation_id: conversationId
                })
                    .then(response => {
                        currentTaskId = response.data.task_id;
                        setActiveStep(2);
                        pollTaskCompletion(currentTaskId, 'Generating requirements...');
                    })
                    .catch(error => {
                        console.error('Error generating requirements:', error);
                        addLogMessage(`Error generating requirements: ${error.message}`, 'error');
                        hideLoading();
                    });
            }
            
            function generateInitialUserMessage(requirements) {
                showLoading('Generating initial user message...', 'Based on persona and requirements');
                
                axios.post('/initial_user_message', {
                    requirements: requirements,
                    conversation_id: conversationId
                })
                    .then(response => {
                        currentTaskId = response.data.task_id;
                        setActiveStep(3);
                        pollTaskCompletion(currentTaskId, 'Generating initial user message...');
                    })
                    .catch(error => {
                        console.error('Error generating initial user message:', error);
                        addLogMessage(`Error generating initial user message: ${error.message}`, 'error');
                        hideLoading();
                    });
            }
            
            function addUserMessageToBackend(message) {
                axios.post('/add_user_message', {
                    message: message,
                    conversation_id: conversationId
                })
                    .then(() => {
                        processModelResponse();
                    })
                    .catch(error => {
                        console.error('Error adding user message:', error);
                        addLogMessage(`Error adding user message: ${error.message}`, 'error');
                    });
            }
            
            function processModelResponse() {
                showLoading('Processing model response...', 'This may take a minute or two');
                setActiveStep(4);
                
                axios.post('/process_model_response', {
                    conversation_id: conversationId
                })
                    .then(response => {
                        currentTaskId = response.data.task_id;
                        pollTaskCompletion(currentTaskId, 'Processing model response...', 'This may take a minute or two');
                    })
                    .catch(error => {
                        console.error('Error processing model response:', error);
                        addLogMessage(`Error processing model response: ${error.message}`, 'error');
                        hideLoading();
                    });
            }
            
            function generateNextUserMessage() {
                showLoading('Generating next user message...', 'Based on conversation history');
                setActiveStep(5);
                
                axios.post('/generate_next_user_message', {
                    conversation_id: conversationId
                })
                    .then(response => {
                        currentTaskId = response.data.task_id;
                        pollTaskCompletion(currentTaskId, 'Generating next user message...');
                    })
                    .catch(error => {
                        console.error('Error generating next user message:', error);
                        addLogMessage(`Error generating next user message: ${error.message}`, 'error');
                        hideLoading();
                    });
            }
            
            // Fix 4: Update conversation function to use API when socket fails
function updateConversationInBackend(result) {
    axios.post('/update_conversation', {
        result: result,
        conversation_id: conversationId
    })
        .then(response => {
            if (response.data.status === 'success') {
                addLogMessage('Conversation updated in backend', 'debug');
                
                // Try to refresh the NER and search results in case WebSockets failed
                if (USE_DIRECT_FETCH || !socket.connected) {
                    setTimeout(() => {
                        fetchNERResultsDirectly();
                        fetchSearchResultsDirectly();
                    }, 1000);
                }
            } else {
                addLogMessage(`Error updating conversation: ${response.data.message}`, 'error');
            }
        })
        .catch(error => {
            console.error('Error updating conversation:', error);
            addLogMessage(`Error updating conversation: ${error.message}`, 'error');
            
            // Send feedback about the error
            sendFeedback(`Error updating conversation: ${error.message}`, 'error');
        });
}

// Fix 5: Add troubleshooting button to UI
function addTroubleshootButton() {
    const troubleshootBtn = document.createElement('button');
    troubleshootBtn.id = 'troubleshootBtn';
    troubleshootBtn.className = 'btn btn-warning ms-2';
    troubleshootBtn.innerHTML = '<i class="bi bi-wrench"></i> Troubleshoot';
    troubleshootBtn.addEventListener('click', troubleshootConnection);
    
    // Add after save button
    document.getElementById('saveConversationBtn').parentNode.appendChild(troubleshootBtn);
}
function saveConversation(name) {
    showLoading('Saving conversation...', 'This will create JSON files');
    
    // First check if server is responsive
    checkServerHealth()
        .then(isHealthy => {
            if (isHealthy) {
                // Use the ensureSaveCompletes function that has a fallback mechanism
                ensureSaveCompletes(name);
            } else {
                // If server is not healthy, try direct UI-based save
                console.warn('Server appears unhealthy, attempting client-side backup');
                addLogMessage('Server health check failed, attempting client-side backup', 'warning');
                
                try {
                    const conversation = getConversationFromUI();
                    const backupData = {
                        name: name,
                        timestamp: new Date().toISOString(),
                        conversation: conversation
                    };
                    
                    // Save to localStorage as backup
                    const backups = JSON.parse(localStorage.getItem('conversation_backups') || '[]');
                    backups.push(backupData);
                    localStorage.setItem('conversation_backups', JSON.stringify(backups));
                    
                    addLogMessage('Conversation backed up to browser storage', 'debug');
                    alert('Server appears to be unresponsive. Your conversation has been backed up to browser storage as a precaution.');
                    
                    // Try server save anyway
                    ensureSaveCompletes(name);
                } catch (error) {
                    console.error('Error creating client-side backup:', error);
                    addLogMessage(`Error creating client-side backup: ${error.message}`, 'error');
                    
                    // Still try server save
                    ensureSaveCompletes(name);
                }
            }
        });
}
function restoreBackups() {
    try {
        const backups = JSON.parse(localStorage.getItem('conversation_backups') || '[]');
        
        if (backups.length === 0) {
            addLogMessage('No local backups found', 'debug');
            return;
        }
        
        addLogMessage(`Found ${backups.length} local backups`, 'debug');
        
        // Create backup display
        const backupContainer = document.createElement('div');
        backupContainer.className = 'backup-container mt-3 mb-3';
        backupContainer.innerHTML = `
            <div class="alert alert-info">
                <h5>Local Backups Found</h5>
                <p>Found ${backups.length} conversation backups in browser storage.</p>
                <div class="backup-list">
                    ${backups.map((backup, index) => `
                        <div class="backup-item border p-2 mb-2 rounded">
                            <div><strong>${backup.name}</strong> - ${new Date(backup.timestamp).toLocaleString()}</div>
                            <div>Messages: ${backup.conversation.length}</div>
                            <button class="btn btn-sm btn-primary restore-backup-btn" data-index="${index}">Restore</button>
                            <button class="btn btn-sm btn-outline-danger delete-backup-btn" data-index="${index}">Delete</button>
                        </div>
                    `).join('')}
                </div>
                <button class="btn btn-sm btn-secondary clear-all-backups-btn">Clear All Backups</button>
            </div>
        `;
        
        // Add to page
        document.querySelector('.card:first-of-type .card-body').appendChild(backupContainer);
        
        // Add event listeners
        document.querySelectorAll('.restore-backup-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const index = parseInt(btn.getAttribute('data-index'));
                const backup = backups[index];
                
                // Confirm restore
                if (confirm(`Restore conversation "${backup.name}" from ${new Date(backup.timestamp).toLocaleString()}?`)) {
                    // Clear current conversation UI
                    conversationBox.querySelector('.message-container').innerHTML = '';
                    
                    // Add messages to UI
                    backup.conversation.forEach(msg => {
                        addMessageToUI(msg.role, msg.content);
                    });
                    
                    addLogMessage(`Restored conversation from local backup: ${backup.name}`, 'debug');
                    
                    // Update step based on conversation length
                    if (backup.conversation.length > 0) {
                        // If we have messages, we're at least at step 4
                        setActiveStep(4);
                        
                        // If the last message is from the assistant, we're at step 5
                        if (backup.conversation[backup.conversation.length - 1].role === 'assistant') {
                            setActiveStep(5);
                        }
                    }
                    
                    // Try to save backup to server
                    showLoading('Saving restored conversation...', 'Sending to server');
                    
                    axios.post('/save_conversation_direct', {
                        name: `${backup.name}_restored`,
                        conversation_id: conversationId,
                        conversation: backup.conversation
                    })
                        .then(response => {
                            if (response.data.status === 'success') {
                                addLogMessage(`Backup saved to server as: ${backup.name}_restored`, 'debug');
                            } else {
                                addLogMessage(`Error saving backup to server: ${response.data.message}`, 'error');
                            }
                            hideLoading();
                        })
                        .catch(error => {
                            console.error('Error saving backup to server:', error);
                            addLogMessage(`Error saving backup to server: ${error.message}`, 'error');
                            hideLoading();
                        });
                }
            });
        });
        
        document.querySelectorAll('.delete-backup-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const index = parseInt(btn.getAttribute('data-index'));
                
                // Confirm delete
                if (confirm('Delete this backup? This cannot be undone.')) {
                    backups.splice(index, 1);
                    localStorage.setItem('conversation_backups', JSON.stringify(backups));
                    
                    // Refresh display
                    backupContainer.remove();
                    restoreBackups();
                    
                    addLogMessage('Deleted local backup', 'debug');
                }
            });
        });
        
        document.querySelector('.clear-all-backups-btn').addEventListener('click', () => {
            // Confirm clear all
            if (confirm('Clear all local backups? This cannot be undone.')) {
                localStorage.removeItem('conversation_backups');
                backupContainer.remove();
                
                addLogMessage('Cleared all local backups', 'debug');
            }
        });
    } catch (error) {
        console.error('Error handling backups:', error);
        addLogMessage(`Error handling backups: ${error.message}`, 'error');
    }
}

// Fix 15: Add a periodic check for missing data
function setupPeriodicDataChecks() {
    // Check every 30 seconds for missing data
    setInterval(() => {
        // Only run if we're past step 1
        if (currentStep > 1 && conversationId) {
            // Check if important data is missing
            const nerUpdated = nerResults.dataset.lastUpdated || 0;
            const searchUpdated = searchResults.dataset.lastUpdated || 0;
            const timeNow = Date.now();
            
            // If NER or search results are missing and haven't been updated recently
            if ((nerResults.innerHTML.includes('No NER results available yet') ||
                 searchResults.innerHTML.includes('No search results available yet')) &&
                (timeNow - nerUpdated > 60000 && timeNow - searchUpdated > 60000)) {
                
                addLogMessage('Detected missing data, fetching directly', 'debug');
                
                // Fetch missing data
                if (nerResults.innerHTML.includes('No NER results available yet')) {
                    fetchNERResultsDirectly();
                }
                
                if (searchResults.innerHTML.includes('No search results available yet')) {
                    fetchSearchResultsDirectly();
                }
            }
        }
    }, 30000);
}

// Fix 16: Add session recovery mechanism
function checkSessionStatus() {
    if (conversationId) {
        axios.get(`/get_session_data?conversation_id=${conversationId}`)
            .then(response => {
                const data = response.data;
                
                if (data.status === 'error' && data.message.includes('Conversation ID mismatch')) {
                    addLogMessage('Session mismatch detected, attempting recovery', 'warning');
                    
                    // Try to restore session
                    axios.post('/restore_session', {
                        conversation_id: conversationId
                    })
                        .then(restoreResponse => {
                            if (restoreResponse.data.status === 'success') {
                                addLogMessage('Session restored successfully', 'debug');
                                
                                // Update UI with recovered data
                                updateUI();
                            } else {
                                addLogMessage(`Session restore failed: ${restoreResponse.data.message}`, 'error');
                            }
                        })
                        .catch(error => {
                            console.error('Error restoring session:', error);
                            addLogMessage(`Error restoring session: ${error.message}`, 'error');
                        });
                }
            })
            .catch(error => {
                console.error('Error checking session status:', error);
                addLogMessage(`Error checking session status: ${error.message}`, 'error');
            });
    }
}

// Fix 17: Add enhanced socket connection management
function enhanceSocketConnection() {
    // Add more robust connection management
    socket.io.on('reconnect_attempt', attempt => {
        console.log(`Socket.IO reconnection attempt #${attempt}`);
        addLogMessage(`Socket.IO reconnection attempt #${attempt}`, 'debug');
    });
    
    socket.io.on('reconnect', attemptNumber => {
        console.log(`Socket.IO reconnected after ${attemptNumber} attempts`);
        addLogMessage(`Socket.IO reconnected after ${attemptNumber} attempts! ðŸŸ¢`, 'debug');
        
        // Refresh data after reconnection
        if (conversationId) {
            setTimeout(() => {
                updateUI();
            }, 1000);
        }
    });
    
    socket.io.on('reconnect_error', error => {
        console.error('Socket.IO reconnection error:', error);
        addLogMessage(`Socket.IO reconnection error: ${error.message}`, 'error');
    });
    
    socket.io.on('reconnect_failed', () => {
        console.error('Socket.IO reconnection failed');
        addLogMessage('Socket.IO reconnection failed after all attempts ðŸ”´', 'error');
        
        // Alert user
        alert('Real-time updates are not working. The application will continue to function, but you may need to refresh the page manually to see updates.');
    });
}

function troubleshootConnection() {
    // Show a loading indicator
    showLoading('Troubleshooting connections...', 'Testing WebSockets and APIs');
    
    // Add a test event listener
    const testHandler = (data) => {
        console.log('Received test event:', data);
        addLogMessage(`Received test event: ${JSON.stringify(data)}`, 'debug');
    };
    socket.on('test_event', testHandler);
    
    // Check socket connection
    checkWebSocketConnection();
    
    // Fetch data directly to test HTTP endpoints
    fetchNERResultsDirectly();
    fetchSearchResultsDirectly();
    
    // Debug conversation data
    debugConversation();
    
    // Remove the test handler after 5 seconds
    setTimeout(() => {
        socket.off('test_event', testHandler);
        hideLoading();
        
        // Show summary
        const connectionStatus = socket.connected ? 'Connected' : 'Disconnected';
        addLogMessage(`Troubleshooting complete. WebSocket: ${connectionStatus}`, 'debug');
        
        // Offer reconnection options if disconnected
        if (!socket.connected) {
            if (confirm('WebSocket appears to be disconnected. Would you like to reload the page to attempt reconnection?')) {
                location.reload();
            }
        }
    }, 5000);
}

// Fix 6: Add a better "Next" button handler with error recovery
function handleNextButtonClick() {
    if (currentStep === 5) {
        // First try to fetch any missing data
        if (nerResults.innerHTML.includes('No NER results available yet')) {
            fetchNERResultsDirectly();
        }
        
        if (searchResults.innerHTML.includes('No search results available yet')) {
            fetchSearchResultsDirectly();
        }
        
        // Generate next user message and go back to step 4
        generateNextUserMessage();
    }
}

            
            function saveConversation(name) {
    showLoading('Saving conversation...', 'This will create JSON files');
    
    axios.post('/save_conversation', {
        name: name,
        conversation_id: conversationId
    })
        .then(response => {
            if (response.data.status === 'success') {
                addLogMessage(`Conversation saved as: ${name}`, 'debug');
                // Update saved conversations list
                getSavedConversations();
            } else {
                addLogMessage(`Error saving conversation: ${response.data.message}`, 'error');
                alert(`Failed to save conversation: ${response.data.message}`);
            }
            hideLoading();
        })
        .catch(error => {
            console.error('Error saving conversation:', error);
            addLogMessage(`Error saving conversation: ${error.message}`, 'error');
            alert('Failed to save conversation. Check logs for details.');
            hideLoading();
        });
}

// Fix 7: Improve the updateUI function to handle errors
function updateUI() {
    // Check if session data is intact
    axios.get('/get_session_data')
        .then(response => {
            const sessionData = response.data.session_data;
            
            if (sessionData && sessionData.conversation_id === conversationId) {
                // Session is intact, check for missing UI elements
                
                // If persona is missing but session has it
                if (personaDisplay.innerHTML.includes('No persona generated yet') && sessionData.has_persona) {
                    fetchPersonaData();
                }
                
                // If conversation should exist but UI is empty
                if (sessionData.conversation_length > 0 && 
                    conversationBox.querySelector('.message-container').children.length === 0) {
                    // Reload conversation
                    reloadConversationFromBackend();
                }
                
                // Check NER and search results
                if (nerResults.innerHTML.includes('No NER results available yet')) {
                    fetchNERResultsDirectly();
                }
                
                if (searchResults.innerHTML.includes('No search results available yet')) {
                    fetchSearchResultsDirectly();
                }
            }
        })
        .catch(error => {
            console.error('Error checking session data:', error);
            addLogMessage(`Error checking session data: ${error.message}`, 'error');
        });
}

// Fix 8: Add function to reload conversation from backend
function reloadConversationFromBackend() {
    // Show loading
    showLoading('Reloading conversation...', 'Retrieving from server');
    
    axios.post('/get_conversation', {
        conversation_id: conversationId
    })
        .then(response => {
            if (response.data.status === 'success' && response.data.conversation) {
                // Clear existing conversation
                conversationBox.querySelector('.message-container').innerHTML = '';
                
                // Add messages to UI
                const conversation = response.data.conversation;
                conversation.forEach(msg => {
                    addMessageToUI(msg.role, msg.content);
                });
                
                addLogMessage(`Successfully reloaded conversation with ${conversation.length} messages`, 'debug');
                
                // Update step based on conversation length
                if (conversation.length > 0) {
                    // If we have messages, we're at least at step 4
                    setActiveStep(4);
                    
                    // If the last message is from the assistant, we're at step 5
                    if (conversation[conversation.length - 1].role === 'assistant') {
                        setActiveStep(5);
                    }
                }
            } else {
                addLogMessage(`Failed to reload conversation: ${response.data.message}`, 'error');
            }
            
            hideLoading();
        })
        .catch(error => {
            console.error('Error reloading conversation:', error);
            addLogMessage(`Error reloading conversation: ${error.message}`, 'error');
            hideLoading();
        });
}

// Fix 9: Add a save fallback mechanism
function ensureSaveCompletes(name) {
    // Start a timer
    const saveTimeout = setTimeout(() => {
        // If we're still waiting after 10 seconds, try direct file saving
        addLogMessage('Save operation taking longer than expected, trying fallback...', 'warning');
        
        // Use a custom endpoint for direct file saving
        axios.post('/save_conversation_direct', {
            name: name,
            conversation_id: conversationId,
            conversation: getConversationFromUI()  // Get conversation directly from UI
        })
            .then(response => {
                if (response.data.status === 'success') {
                    addLogMessage(`Conversation saved as: ${name} (fallback method)`, 'debug');
                    getSavedConversations();
                } else {
                    addLogMessage(`Error in fallback save: ${response.data.message}`, 'error');
                    alert(`Failed to save conversation. Please try again.`);
                }
                hideLoading();
            })
            .catch(error => {
                console.error('Error in fallback save:', error);
                addLogMessage(`Error in fallback save: ${error.message}`, 'error');
                alert('Failed to save conversation. Please try again.');
                hideLoading();
            });
    }, 10000);
    
    // Regular save function
    axios.post('/save_conversation', {
        name: name,
        conversation_id: conversationId
    })
        .then(response => {
            // Clear the timeout since save completed
            clearTimeout(saveTimeout);
            
            if (response.data.status === 'success') {
                addLogMessage(`Conversation saved as: ${name}`, 'debug');
                getSavedConversations();
            } else {
                addLogMessage(`Error saving conversation: ${response.data.message}`, 'error');
                // Don't hide loading - let the fallback handle it
                return;
            }
            hideLoading();
        })
        .catch(error => {
            // Don't clear timeout - let the fallback handle it
            console.error('Error saving conversation:', error);
            addLogMessage(`Error saving conversation: ${error.message}`, 'error');
            // Don't hide loading - let the fallback handle it
        });
}

function checkServerHealth() {
    return new Promise((resolve, reject) => {
        axios.get('/debug')
            .then(response => {
                if (response.data && response.data.status === 'success') {
                    resolve(true);
                } else {
                    resolve(false);
                }
            })
            .catch(error => {
                console.error('Server health check failed:', error);
                resolve(false);
            });
    });
}
            
            function getSavedConversations() {
                axios.get('/get_saved_conversations')
                    .then(response => {
                        const conversations = response.data.conversations;
                        
                        if (conversations.length === 0) {
                            savedConversationsList.innerHTML = '<p class="text-muted">No conversations saved yet.</p>';
                            return;
                        }
                        
                        let html = '<ul class="list-group">';
                        conversations.forEach(conv => {
                            html += `
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <div>
                                        <strong>${conv.name}</strong>
                                        <br>
                                        <small class="text-muted">${conv.timestamp}</small>
                                    </div>
                                    <div>
                                        <a href="${conv.readable_file}" class="btn btn-sm btn-outline-primary me-1" target="_blank">
                                            View
                                        </a>
                                        <a href="${conv.detailed_file}" class="btn btn-sm btn-outline-secondary" download>
                                            Download
                                        </a>
                                    </div>
                                </li>
                            `;
                        });
                        html += '</ul>';
                        
                        savedConversationsList.innerHTML = html;
                    })
                    .catch(error => {
                        console.error('Error getting saved conversations:', error);
                        addLogMessage(`Error getting saved conversations: ${error.message}`, 'error');
                    });
            }
            
            function regenerateAssistantResponse() {
                showLoading('Regenerating assistant response...', 'This may take a minute or two');
                
                axios.post('/regenerate_assistant_response', {
                    conversation_id: conversationId
                })
                    .then(response => {
                        currentTaskId = response.data.task_id;
                        pollTaskCompletion(currentTaskId, 'Regenerating assistant response...', 'This may take a minute or two');
                    })
                    .catch(error => {
                        console.error('Error regenerating assistant response:', error);
                        addLogMessage(`Error regenerating assistant response: ${error.message}`, 'error');
                        hideLoading();
                    });
            }
            
            function clearConversation() {
                if (!confirm('Are you sure you want to clear the current conversation? This will keep the persona and requirements.')) {
                    return;
                }
                
                showLoading('Clearing conversation...', 'Keeping persona and requirements');
                
                axios.post('/clear_conversation')
                    .then(() => {
                        conversationBox.querySelector('.message-container').innerHTML = '';
                        nerResults.innerHTML = '<span class="text-muted">No NER results available yet.</span>';
                        searchCall.innerHTML = '<span class="text-muted">No search call available yet.</span>';
                        searchResults.innerHTML = '<span class="text-muted">No search results available yet.</span>';
                        critique.innerHTML = '<span class="text-muted">No critique available yet.</span>';
                        
                        setActiveStep(3);
                        
                        hideLoading();
                        addLogMessage('Conversation cleared', 'debug');
                        
                        generateInitialUserMessage(requirementsDisplay.querySelector('pre').textContent);
                    })
                    .catch(error => {
                        console.error('Error clearing conversation:', error);
                        addLogMessage(`Error clearing conversation: ${error.message}`, 'error');
                        hideLoading();
                    });
            }
            
            function resetEverything() {
                if (!confirm('Are you sure you want to reset everything? This will start from scratch.')) {
                    return;
                }
                
                showLoading('Resetting...', 'Starting from scratch');
                
                axios.post('/reset')
                    .then(() => {
                        conversationBox.querySelector('.message-container').innerHTML = '';
                        personaDisplay.innerHTML = '<span class="text-muted">No persona generated yet.</span>';
                        requirementsDisplay.innerHTML = '<span class="text-muted">No requirements generated yet.</span>';
                        nerResults.innerHTML = '<span class="text-muted">No NER results available yet.</span>';
                        searchCall.innerHTML = '<span class="text-muted">No search call available yet.</span>';
                        searchResults.innerHTML = '<span class="text-muted">No search results available yet.</span>';
                        critique.innerHTML = '<span class="text-muted">No critique available yet.</span>';
                        
                        setActiveStep(1);
                        
                        conversationId = null;
                        
                        nextBtn.disabled = true;
                        clearBtn.disabled = true;
                        regenerateBtn.disabled = true;
                        saveConversationBtn.disabled = true;
                        
                        hideLoading();
                        addLogMessage('Everything reset', 'debug');
                    })
                    .catch(error => {
                        console.error('Error resetting:', error);
                        addLogMessage(`Error resetting: ${error.message}`, 'error');
                        hideLoading();
                    });
            }
            
            startBtn.addEventListener('click', () => {
                initConversation();
            });
            
            nextBtn.addEventListener('click', () => {
                if (currentStep === 5) {
                    generateNextUserMessage();
                }
            });
            
            clearBtn.addEventListener('click', () => {
                clearConversation();
            });
            
            resetBtn.addEventListener('click', () => {
                resetEverything();
            });
            
            regenerateBtn.addEventListener('click', () => {
                regenerateAssistantResponse();
            });
            
            saveConversationBtn.addEventListener('click', () => {
                saveConversationModal.show();
            });
            
            saveConversationModalBtn.addEventListener('click', () => {
                const name = document.getElementById('conversationName').value || `Conversation-${new Date().toISOString().slice(0, 19).replace('T', '-').replace(/:/g, '')}`;
                saveConversation(name);
                saveConversationModal.hide();
            });
            
            getSavedConversations();
        });
    </script>
</body>
</html>